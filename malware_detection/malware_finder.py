#!/usr/bin/env python3

import argparse
import hashlib
import multiprocessing
import os
import re
import signal
import sys
import time
import traceback
from datetime import datetime

version    = "2.0.12"
sigs       = []
signatures = len(sigs)
now        = datetime.now()
date_time  = now.strftime("%Y/%m/%d - %H:%M")

MIN = (3, 3)
if not sys.version_info >= MIN:
    raise EnvironmentError(
        f"Python version too low, required at least {'.'.join(map(str, MIN))}")

sigs = []

class TimeoutException(Exception):
    pass

def timeout_handler(signum, frame):
    """
    This function is used to handle timeouts when scanning files.

    Args:
        signum (int): The signal number.
        frame (Frame): The frame object.

    Raises:
        TimeoutException: A timeout exception.
    """    
    raise TimeoutException

signal.signal(signal.SIGALRM, timeout_handler)

def load_whitelist(directory_path):
    """
    This function loads the whitelist of files that should not be scanned.

    Args:
        directory_path (str): The path to the directory containing the whitelist.

    Returns:
        set: The set of files in the whitelist.
    """    
    file_path = "whitelist.db"
    whitelist = set()
    if os.path.exists(file_path):
        with open(file_path, "r") as f:
            for line in f:
                line = line.strip()
                if not line.startswith('#'):
                    whitelist.add(line)
    return whitelist

def load_signatures():
    """
    This function loads the set of signatures that will be used to scan files.

    Returns:
        set: The set of signatures.
    """    
    file_path = "signatures.db"
    sigs = []
    with open(file_path, "r") as f:
        for line in f:
            signature = line.strip()
            if signature:
                sigs.append(re.compile(signature))
    return sigs

def handle_sigint(sig, frame):
    """
    This function is used to handle SIGINT (Ctrl+C) signals.

    Args:
        sig (int): The signal number.import os; max_processes = max(1, os.cpu_count() // 2) if os.cpu_count() else 1

        frame (Frame): The frame object.

    Raises:
        SystemExit: A system exit exception.
    """    
    print("\nExiting\n")
    raise SystemExit()

def move_to_quarantine(file_path):
    """
    This function moves a file to quarantine if it is detected as malware.

    Args:
        file_path (str): The path to the file.

    Returns:
        None: None.
    """    
    try:
        new_path = file_path + ".disabled"
        os.rename(file_path, new_path)
        print(f"File {file_path} moved to quarantine as {new_path}")
    except Exception as e:
        print(f"Failed to move {file_path} to quarantine: {str(e)}")
        
def scan_file(file_path, sigs, verbose, output_file, debug, quarantine=False):
    """
    Scan a file for malware.

    Args:
        file_path (str): The path to the file.
        sigs (set): The set of signatures.
        verbose (bool): Whether to print verbose output.
        output_file (str): The path to the output file.
        debug (bool): Whether to enable debug mode.
        quarantine (bool): Whether to quarantine detected files.

    Returns:
        bool: True if malware was found, False otherwise.
    """    
    try:
        print(f"Scanning file: {file_path}")
        start_time = time.time()
        chunk_size = 1024 * 1024  # 1 MB
        with open(file_path, "rb") as f:
            while True:
                content = f.read(chunk_size)
                if not content:
                    break
                content = content.decode(errors='ignore')
                for sig in sigs:
                    sig_start_time = time.time()
                    signal.alarm(10)
                    try:
                        match = sig.search(content)
                    except TimeoutException:
                        print(f"Skipping regex {sig.pattern} due to timeout")
                        with open('regex-fail.log', 'a') as log_file:
                            log_file.write(f"Skipping regex {sig.pattern} due to timeout\n")
                        continue
                    else:
                        signal.alarm(0)
                    sig_elapsed_time = time.time() - sig_start_time
                    if match:
                        pattern = sig.pattern
                        message = f"Found signature {pattern} in file: {file_path}" if verbose else f"Found signature in file: {file_path}"
                        print(message)
                        with open(output_file, "a") as out_f:
                            out_f.write(f"{file_path}\n")
                        if quarantine:
                            move_to_quarantine(file_path)
                        return True
                    if debug:
                        print(f"Benchmark - Regex: {sig.pattern}, Time: {sig_elapsed_time} seconds")
        if verbose:
            print(f"No match found in file: {file_path}")
        if debug:
            elapsed_time = time.time() - start_time
            print(f"Benchmark - File: {file_path}, Total Time: {elapsed_time} seconds")
        return False
    except IOError:
        print(f"Failed to open {file_path}. Skipping.")
        return False
    except UnicodeDecodeError:
        print(f"Failed to decode {file_path}. Skipping.")
        return False
    except KeyboardInterrupt:
        print('Interrupted')
        return False
    except Exception as e:
        traceback.print_exc()
        return False

def scan_directory(directory_path, extension, args, sigs, quarantine=False):    
    """
    Scan a directory for files with suspicious signatures.

    Args:
        directory_path (str): The path to the directory to scan.
        extension (str): The file extension to scan for.
        args (argparse.Namespace): The command line arguments.
        quarantine (bool): Whether to quarantine detected files.

    Returns:
        None: None.
    """    
    output_file = args.file if args.file else "found_files.txt"
    malware_count = 0
    whitelist = load_whitelist(directory_path) if args.whitelist else set()
    if args.individual:
        if not os.path.isfile(directory_path):
            raise ValueError(f"{directory_path} is not a valid file")
        print(f"Scanning file {directory_path} for signatures")
        try:
            if scan_file(directory_path, sigs, args.verbose, output_file, args.debug, quarantine):
                malware_count += 1
        except Exception as e:
            traceback.print_exc()
        print(f"Found {malware_count} instances of malware in {directory_path}")
        with open(output_file, "a") as out_f:
            out_f.write(f"\nFound {malware_count} instances of malware in {directory_path}\n")
    else:
        print(f"Scanning directory {directory_path} and files with extension {extension}")
        file_paths = []
        for root, _, files in os.walk(directory_path):
            for file_name in files:
                if file_name.endswith(extension):
                    file_path = os.path.join(root, file_name)
                    if not os.path.islink(file_path):
                        rel_path = os.path.relpath(file_path, directory_path)
                        if not any(whitefile in rel_path for whitefile in whitelist):
                            file_paths.append(file_path)
        max_processes = max(1, os.cpu_count() // 2) if os.cpu_count() else 1
        with multiprocessing.Pool(processes=max_processes) as pool:
            results = pool.starmap(scan_file, [(file_path, sigs, args.verbose, output_file, args.debug, quarantine) for file_path in file_paths])
        malware_count = sum(results)
        print(f"Found {malware_count} files with malware.")
        with open(output_file, "a") as out_f:
            out_f.write(f"\nFound {malware_count} files with malware.\n")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Scan a directory for files with suspicious signatures")
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument("-i", "--individual", help="Path to individual file to scan")
    group.add_argument("-d", "--directory", help="Path to directory to scan")
    parser.add_argument("-v", "--verbose", help="increase output verbosity", action="store_true")
    parser.add_argument("-f", "--file", help="output file name")
    parser.add_argument("-e", "--extension", default="php", help="File extension to scan for")
    parser.add_argument("--debug", help="Enable debug mode (Show benchmark info)", action="store_true")
    parser.add_argument("-q", "--quarantine", help="Enable quarantine mode (Rename detected files)", action="store_true")
    parser.add_argument("-w", "--whitelist", help="Enable whitelist mode (Ignore files in whitelist)", action="store_true") 
    sigs = load_signatures() # Load the signatures here and use them as needed
    signatures = len(sigs)

    banner = f"""
-----------------------------------------------------------------------------------
Malware Finder {version}
Signatures Loaded: {signatures}
-----------------------------------------------------------------------------------
Scan date:  {date_time}
-----------------------------------------------------------------------------------
"""
    print(banner)
    if len(sys.argv)==1:
        parser.print_help(sys.stderr)
        sys.exit(1)
        
    args = parser.parse_args()
    signal.signal(signal.SIGINT, handle_sigint)

    if args.individual:
        scan_file(args.individual, sigs, args.verbose, args.file, args.debug, args.quarantine)
    else:
        scan_directory(args.directory, args.extension, args, sigs, args.quarantine)